import numpy as np
import random
np.random.seed(1) #указание, чтобы при перезапуске кода числа были такие-же но случайные
A=2  #число приемников
B=3 #число нейронов в слое
C=1 #число слоев
D=1 #число нейронов в выходе    

output=np.array([      #фигачим исходники (в норм программах они иначе берутся)      
 
])
b=[np.random.randn(1,B),          # список, который хранит мытрицы векторов смещения.заполним векторы смещеения случайными числами 
 np.random.randn(1,D)
]
b=[b[0]]*(C)+[b[1]] #тк число слоев вариативно, а число мытриц векторов смещения должно быть равночислу слоев+1, необходимо сделать плавающим список, причем число элементов добавляемых векторов должно быть равно числу нейронов
print(b)
w=[np.random.randn(A,B),        #список, который хранит мытрицы весов смещения. заполним массив весов случайными числами
   np.random.randn(B,B),   
   np.random.randn(B,D)
]
w=[w[0]]+[w[1]]*(C-1)+[w[2]] #тк число слоев вариативно, а число мытриц весов должно быть равночислу слоев+1, необходимо сделать плавающим список,причем добавляемые матрицы должны иметь размер число нейронов*число нейронов
def deltasigmoid(x):  #прописываем производной функцию сигмоиды
   return 1/(1+np.power(2.82,-x))
def sigmoid(x): #прописываем функцию сигмоиды
    return 1/(1+np.exp(-x))
def mistake(x,y):
    return x-y  #прописываем нахождение ошибки
def solver(x,n): #прописывем то, что в своей сути делает нейросеть, n - номер слоя
    return sigmoid(x @ w[n-1] +b[n-1])
#input=(np.random.randn(1,A)) #исходные данные
def backprop(y,x,n): #y-входники слоя x-ошибка в конце слоя n-номер слоя 
    deltab=np.multiply(deltasigmoid(solver(y, n)), x) #находит градиент ошибки по выходу слоя но до сигмоиды, оно же равно градиенту ошибки по вектору смещения
    deltaw=np.matrix(y).T @ deltab  #находит градиент ошибки по весам слоя 
    deltah=deltab @ w[n-1].T #находит градиент ошибки по исходникам слоя
    return [deltab,deltaw,deltah]
for it in range(300000):
    U=np.array([np.random.choice([0,1]),np.random.choice([0,1]) ])
    if (U==np.array([1, 1])).all():
       true=np.array([0])
    elif (U==np.array([0, 1])).all():
       true=np.array([1])
    elif (U==np.array([1, 0])).all():
      true=np.array([1])

    elif (U==np.array([0, 0])).all():
      true=np.array([1]) 
    T=0 #костыль
    fake=U #костыль
    for T in range(C+1): # находим истинные значения при данных параметрах (цикл тк число слоев вариативно)
            fake=solver(fake, T+1)
            T=T+1
    mis=fake-true #ищем ошибку(не факт что верно)
    g=C #костыль
    i=0 #костыль
    alfa=1
    
    for i in range(g+1): # обучение
        k=C #костыль
        U1=U #костыль
        for k in range(g): #ищем входники слоя
           U1=solver(U1, k+1)
        prop=backprop(U1,mis,g+1)
        
        mis=prop[2] #обновляем ошибку на найденную
        print(mis)
        w[g]=w[g]-prop[1]*alfa #обновляем веса слоя учитывая ошибку
        b[g]=b[g]-prop[0]*alfa #бновляем вектор смещения слоя учитывая ошибку
        g=g-1
    print(true)
    print(fake)

    
